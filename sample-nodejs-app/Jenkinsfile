#!/usr/bin/env groovy

/**
 * Jenkinsfile - Pipeline CI/CD pour Sample Node.js App
 * 
 * Ce pipeline d√©montre les meilleures pratiques CI/CD:
 * - Build multi-√©tapes avec validation
 * - Tests automatis√©s
 * - Analyse de qualit√© de code
 * - Construction d'image Docker
 * - D√©ploiement automatis√©
 */

pipeline {
    agent {
        label 'docker'
    }
    
    tools {
        nodejs 'node'  // Configur√© dans Jenkins Global Tool Configuration
    }
    
    environment {
        // Variables d'environnement
        APP_NAME = 'sample-nodejs-app'
        DOCKER_IMAGE = "${APP_NAME}:${BUILD_NUMBER}"
        DOCKER_IMAGE_LATEST = "${APP_NAME}:latest"
        STAGING_SERVER = 'staging-server'
        STAGING_PORT = '8082'
        
        // Credentials (√† configurer dans Jenkins)
        // DOCKER_REGISTRY_CREDS = credentials('docker-registry')
        // SONARQUBE_TOKEN = credentials('sonarqube-token')
    }
    
    options {
        // Options du pipeline
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
    }
    
    stages {
        
        stage('üìã Initialization') {
            steps {
                script {
                    echo '='.repeat(50)
                    echo "üöÄ Starting CI/CD Pipeline"
                    echo "üì¶ Application: ${APP_NAME}"
                    echo "üè∑Ô∏è  Build Number: ${BUILD_NUMBER}"
                    echo "üî® Build ID: ${BUILD_ID}"
                    echo "üë§ Started by: ${BUILD_USER ?: 'SCM'}"
                    echo '='.repeat(50)
                    
                    // Afficher les informations de l'environnement
                    sh '''
                        echo "Node version: $(node --version)"
                        echo "NPM version: $(npm --version)"
                        echo "Docker version: $(docker --version)"
                    '''
                }
            }
        }
        
        stage('üì¶ Checkout') {
            steps {
                echo 'üì• R√©cup√©ration du code source...'
                checkout scm
                
                script {
                    // Afficher les informations Git
                    sh '''
                        echo "Git Branch: $(git branch --show-current)"
                        echo "Git Commit: $(git rev-parse --short HEAD)"
                        echo "Git Author: $(git log -1 --pretty=format:'%an')"
                    '''
                }
            }
        }
        
        stage('üîç Code Analysis') {
            parallel {
                stage('Lint') {
                    steps {
                        echo 'üîç Analyse du code avec ESLint...'
                        sh 'npm install --save-dev eslint'
                        sh 'npm run lint || true'
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        echo 'üîí Analyse de s√©curit√© des d√©pendances...'
                        sh 'npm audit --audit-level=moderate || true'
                    }
                }
            }
        }
        
        stage('üìö Install Dependencies') {
            steps {
                echo 'üìö Installation des d√©pendances NPM...'
                sh 'npm ci'
                
                script {
                    // Afficher les d√©pendances install√©es
                    sh 'npm list --depth=0'
                }
            }
        }
        
        stage('üß™ Run Tests') {
            steps {
                echo 'üß™ Ex√©cution des tests unitaires...'
                sh 'npm test'
            }
            post {
                always {
                    // Archiver les r√©sultats de tests
                    junit(testResults: '**/junit.xml', allowEmptyResults: true)
                    
                    // Publier le rapport de couverture
                    publishHTML(target: [
                        allowMissing: true,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'coverage',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report'
                    ])
                }
            }
        }
        
        stage('üê≥ Build Docker Image') {
            steps {
                script {
                    echo 'üê≥ Construction de l\'image Docker...'
                    
                    // Construire l'image avec le plugin Docker
                    docker.build("${DOCKER_IMAGE}", ".")
                    
                    // Tagger aussi comme latest
                    sh "docker tag ${DOCKER_IMAGE} ${DOCKER_IMAGE_LATEST}"
                    
                    echo "‚úÖ Image construite: ${DOCKER_IMAGE}"
                }
            }
        }
        
        stage('‚úÖ Test Docker Image') {
            steps {
                script {
                    echo '‚úÖ Test de l\'image Docker...'
                    
                    // Tester que l'image d√©marre correctement
                    docker.image("${DOCKER_IMAGE}").inside {
                        sh '''
                            echo "=== Test de l'image Docker ==="
                            ls -la
                            cat package.json
                            node --version
                            npm --version
                        '''
                    }
                    
                    // Optionnel: d√©marrer un conteneur et tester l'endpoint
                    sh """
                        echo "D√©marrage d'un conteneur de test..."
                        CONTAINER_ID=\$(docker run -d -p 3001:3000 ${DOCKER_IMAGE})
                        echo "Container ID: \$CONTAINER_ID"
                        
                        # Attendre que l'application d√©marre
                        sleep 5
                        
                        # Tester le health check
                        curl -f http://localhost:3001/health || exit 1
                        
                        # Arr√™ter et supprimer le conteneur
                        docker stop \$CONTAINER_ID
                        docker rm \$CONTAINER_ID
                        
                        echo "‚úÖ Tests de l'image r√©ussis"
                    """
                }
            }
        }
        
        stage('üöÄ Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo 'üöÄ D√©ploiement sur le serveur de staging...'
                    
                    try {
                        // Arr√™ter les anciens conteneurs
                        sh """
                            docker ps -a --filter "name=${APP_NAME}" -q | xargs -r docker stop || true
                            docker ps -a --filter "name=${APP_NAME}" -q | xargs -r docker rm || true
                        """
                        
                        // D√©marrer le nouveau conteneur
                        sh """
                            docker run -d \
                                --name ${APP_NAME} \
                                --network jenkins-lab_jenkins-network \
                                -p ${STAGING_PORT}:3000 \
                                --restart unless-stopped \
                                -e NODE_ENV=staging \
                                ${DOCKER_IMAGE}
                        """
                        
                        // Attendre que l'application d√©marre
                        sleep 10
                        
                        // V√©rifier que l'application r√©pond
                        sh """
                            curl -f http://localhost:${STAGING_PORT}/health || exit 1
                            curl http://localhost:${STAGING_PORT}/deployment/test
                        """
                        
                        echo "‚úÖ D√©ploiement r√©ussi sur http://localhost:${STAGING_PORT}"
                        
                    } catch (Exception e) {
                        echo "‚ùå √âchec du d√©ploiement: ${e.message}"
                        throw e
                    }
                }
            }
        }
        
        stage('üîç Post-Deployment Tests') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo 'üîç Tests post-d√©ploiement...'
                    
                    sh """
                        # Test de tous les endpoints
                        echo "Test endpoint principal..."
                        curl -f http://localhost:${STAGING_PORT}/ | jq .
                        
                        echo "Test health check..."
                        curl -f http://localhost:${STAGING_PORT}/health | jq .
                        
                        echo "Test version..."
                        curl -f http://localhost:${STAGING_PORT}/version | jq .
                        
                        echo "‚úÖ Tous les tests post-d√©ploiement sont pass√©s"
                    """
                }
            }
        }
    }
    
    post {
        always {
            echo 'üßπ Nettoyage...'
            
            // Nettoyer le workspace
            cleanWs(
                deleteDirs: true,
                disableDeferredWipeout: true,
                notFailBuild: true
            )
        }
        
        success {
            echo '='.repeat(50)
            echo '‚úÖ PIPELINE R√âUSSI!'
            echo "üì¶ Application: ${APP_NAME}"
            echo "üè∑Ô∏è  Version: ${BUILD_NUMBER}"
            echo "üê≥ Image: ${DOCKER_IMAGE}"
            
            script {
                if (env.BRANCH_NAME == 'main') {
                    echo "üöÄ D√©ploy√© sur: http://localhost:${STAGING_PORT}"
                }
            }
            
            echo '='.repeat(50)
            
            // Optionnel: Envoyer une notification
            // slackSend(color: 'good', message: "Pipeline ${APP_NAME} #${BUILD_NUMBER} r√©ussi!")
        }
        
        failure {
            echo '='.repeat(50)
            echo '‚ùå PIPELINE √âCHOU√â!'
            echo "üì¶ Application: ${APP_NAME}"
            echo "üè∑Ô∏è  Build: ${BUILD_NUMBER}"
            echo "üìã Logs: ${BUILD_URL}console"
            echo '='.repeat(50)
            
            // Optionnel: Envoyer une notification
            // slackSend(color: 'danger', message: "Pipeline ${APP_NAME} #${BUILD_NUMBER} √©chou√©!")
        }
        
        unstable {
            echo '‚ö†Ô∏è  Pipeline instable - v√©rifier les warnings'
        }
    }
}
